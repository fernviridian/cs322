/* Generated By:JavaCC: Do not edit this line. Parser.java */
import ast.*;

public class Parser implements ParserConstants {
  public static void main(String[] args) {
     new Parser(System.in);
     try {
       Defn[] program = Top();
       new IndentOutput(System.out).indent(program);
     } catch (ParseException e) {
       System.out.println("Invalid syntax at ("
                          + token.beginColumn + ","
                          + token.beginLine + "), "
                          + token.image);
     } catch (TokenMgrError e) {
       System.out.println(e.getMessage());
     }
  }

//- Expressions -------------------------------------------------------

// The set of expressions in our language is built from identifiers
// and integer literals using a set of operators whose precedence is
// captured by the following table.  (The same table was given in the
// assignment as part of the description of Expr, except for the line
// at the top that corresponds to assignment, which was introduced in
// Assign):

//   =                     Assignment, groups to the right
//   ||                    Logical or, groups to the right
//   &&                    Logical and, groups to the right
//   <, <=, >, >=, ==, !=  Comparison operators, nonassociative
//   +, -                  Additive operators, group to the left
//   *, /                  Multiplicative operators, group to the left
//   parentheses           Used to specify explicit order of operations

// We use one nonterminal for each row in the table above.  As described
// in the slides, there are standard patterns that we can use for left-,
// right-, and non-associative operators:
//
//       right associative   nonassociative     left associative
//         E -> A OP E         E -> A OP A        E -> E + A
//         E -> A              E -> A             E -> A
//
// In each of these examples, E and A are the nonterminals for adjacent
// rows in the table above, with E being lower precedence (i.e., earlier
// in the table) than A.  As discussed in labs, we can translated these
// in to compact JavaCC grammars by applying left factoring to the right
// and non associative cases, and by eliminating left recursion for the
// left associative case, resulting in the following general rules:
//
//       right associative   nonassociative     left associative
//         E -> A (OP E)?      E -> A (OP A)?     E -> A (OP A)*

// Applying these patterns leads to the following definitions:
  static final public Expr Expr() throws ParseException {
               Expr e;
    if (jj_2_1(2)) {
      // assignments and LOrs can both start with
          e = Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 10:
      case 13:
      case IDENT:
      case INTLIT:
      case FLOATLIT:
        e = LOr();
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

                              // expression is an assignment.
  static final public Expr LOr() throws ParseException {
              Expr e, f;
    // Logical or groups to the right:
      e = LAnd();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 1:
      jj_consume_token(1);
      f = LOr();
                           e = new LOr(e, f);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  static final public Expr LAnd() throws ParseException {
               Expr e, f;
    // Logical and groups to the right:
      e = Comp();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 2:
      jj_consume_token(2);
      f = LAnd();
                            e = new LAnd(e, f);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  static final public Expr Comp() throws ParseException {
               Expr e, f;
    // Comparisons are nonassociative:
      e = Sum();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 3:
        jj_consume_token(3);
        f = Sum();
                          e = new Lt (e, f);
        break;
      case 4:
        jj_consume_token(4);
        f = Sum();
                          e = new Lte(e, f);
        break;
      case 5:
        jj_consume_token(5);
        f = Sum();
                          e = new Gt (e, f);
        break;
      case 6:
        jj_consume_token(6);
        f = Sum();
                          e = new Gte(e, f);
        break;
      case 7:
        jj_consume_token(7);
        f = Sum();
                          e = new Eql(e, f);
        break;
      case 8:
        jj_consume_token(8);
        f = Sum();
                          e = new Neq(e, f);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  static final public Expr Sum() throws ParseException {
              Expr e, f;
    // Additive operations group to the left:
      e = Prod();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 9:
      case 10:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 9:
        jj_consume_token(9);
        f = Prod();
                            e = new Add(e, f);
        break;
      case 10:
        jj_consume_token(10);
        f = Prod();
                            e = new Sub(e, f);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  static final public Expr Prod() throws ParseException {
               Expr e, f;
    // Multiplicatives group to the left:
      e = Atom();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 11:
      case 12:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 11:
        jj_consume_token(11);
        f = Atom();
                            e = new Mul(e, f);
        break;
      case 12:
        jj_consume_token(12);
        f = Atom();
                            e = new Div(e, f);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

// All remaining forms of expression fit in to the Atom nonterminal
// that is described by the next function.  This includes
// parenthesized expressions, identifiers, and integer literals.
//
// Note that this is also the appropriate place to insert the rules
// for parsing a function call: if we had tried, instead to add
// the rule for calls as an extra rule in our Expr function, for
// example, then we would not be able to use function calls as
// arguments to any of the operators, unless those calls were
// enclosed in parentheses.  (For example, it would be necessary to
// write (f(x))+(g(x)) instead of just f(x)+g(x).)
//
// Once again, we need a LOOKAHEAD(2) so that we can distinguish
// between function calls and simple identifiers.  Both of those
// constructs start with an <IDENT> token, but only the former can
// (and must) be followed by an "(" token, which is why a lookahead
// of two is enough to distinguish between these cases.
  static final public Expr Atom() throws ParseException {
               Expr e; Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 13:
      jj_consume_token(13);
      e = Expr();
      jj_consume_token(14);
      break;
    case 10:
      jj_consume_token(10);
      e = Atom();
                   e = new UMinus(e);
      break;
    default:
      jj_la1[9] = jj_gen;
      if (jj_2_2(2)) {
        e = Call();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          t = jj_consume_token(IDENT);
                   e = new Id(t.image);
          break;
        case INTLIT:
          t = jj_consume_token(INTLIT);
                   e = new IntLit(Integer.parseInt(t.image));
          break;
        case FLOATLIT:
          t = jj_consume_token(FLOATLIT);
                   e = new FloatLit(Float.parseFloat(t.image));
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

// We have broken out the rules for parsing assignments and calls in to
// separate functions.  This has two benefits.  First, it will allow us
// to reuse these functions later when we define the syntax of
// statements, without having to duplicate the productions from our
// grammar.  In addition, it allows us to specify more precise return
// types for these two functions, indicating, not just that they return
// some form of Expr value, but rather that they specifically return an
// Assign and a Call value, respectively.  Again, this will be useful
// when we come to the grammar for statements, because we can only build
// ExprStmt values for certain types of expression.  (Fortunately, both
// Assign and Call are included in that ...) These are nice properties,
// which is why I have chosen to illustrate them here.  But it was not
// actually necessary to use these tricks in your solution: a simple
// alternative would have been to repeat the two productions in each of
// the places where they were needed.  (Please ask me if it's not clear
// what that means!)
  static final public Assign Assignment() throws ParseException {
                       Token t; Expr e;
    t = jj_consume_token(IDENT);
    jj_consume_token(15);
    e = Expr();
    {if (true) return new Assign(t.image, e);}
    throw new Error("Missing return statement in function");
  }

  static final public Call Call() throws ParseException {
               Token t; Expr[] args;
    t = jj_consume_token(IDENT);
    jj_consume_token(13);
    args = Args();
    jj_consume_token(14);
    {if (true) return new Call(t.image, args);}
    throw new Error("Missing return statement in function");
  }

// The grammar for Call above references a production for Args, which
// it uses to parse an array of zero or more argument values in a
// function call.  We will present the definition of that function
// later in this file when we discuss formal parameters, which uses
// exactly the same approach/structure.

// So that just about wraps things up for ExprAST and AssignAST!

//- Statements --------------------------------------------------------

// As described in the assignment text, there are several different
// forms of statement, all of which are captured as alternatives in
// the following parsing function:
  static final public Stmt Stmt() throws ParseException {
               Expr e=null; Stmt s1, s2 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 16:
      jj_consume_token(16);
    {if (true) return new Empty();}
      break;
    case 25:
      s1 = Block();
    {if (true) return s1;}
      break;
    case 17:
      jj_consume_token(17);
      jj_consume_token(13);
      e = Expr();
      jj_consume_token(14);
      s1 = Stmt();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 18:
        jj_consume_token(18);
        s2 = Stmt();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
    {if (true) return new If(e, s1, s2);}
      break;
    case 19:
      jj_consume_token(19);
      jj_consume_token(13);
      e = Expr();
      jj_consume_token(14);
      s1 = Stmt();
    {if (true) return new While(e, s1);}
      break;
    case 20:
      jj_consume_token(20);
      s1 = Stmt();
      jj_consume_token(19);
      jj_consume_token(13);
      e = Expr();
      jj_consume_token(14);
      jj_consume_token(16);
    {if (true) return new DoWhile(s1, e);}
      break;
    case 24:
      s1 = ForLoop();
    {if (true) return s1;}
      break;
    case 21:
      jj_consume_token(21);
      jj_consume_token(16);
    {if (true) return new Break();}
      break;
    case 22:
      jj_consume_token(22);
      e = Expr();
      jj_consume_token(16);
    {if (true) return new Print(e);}
      break;
    case 23:
      jj_consume_token(23);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 10:
      case 13:
      case IDENT:
      case INTLIT:
      case FLOATLIT:
        e = Expr();
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      jj_consume_token(16);
    {if (true) return new Return(e);}
      break;
    case 27:
    case 28:
    case 29:
    case IDENT:
      s1 = InitStmt();
    {if (true) return s1;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public InitStmt InitStmt() throws ParseException {
                        InitStmt s1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      s1 = ExprStmt();
      jj_consume_token(16);
    {if (true) return s1;}
      break;
    case 27:
    case 28:
    case 29:
      s1 = Locals();
    {if (true) return s1;}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Stmt ForLoop() throws ParseException {
                  StmtExpr init=null;
                  Expr     test=null;
                  StmtExpr step=null;
                  Stmt     body;
    jj_consume_token(24);
    jj_consume_token(13);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      init = StmtExpr();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(16);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 10:
    case 13:
    case IDENT:
    case INTLIT:
    case FLOATLIT:
      test = Expr();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(16);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      step = StmtExpr();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(14);
    body = Stmt();
    {if (true) return new For(init, test, step, body);}
    throw new Error("Missing return statement in function");
  }

// The alternatives in the code above are listed in the same order as
// the descriptions in the assignment text, following the concrete
// syntax that was described in each case.  We have captured the
// appropriate syntax for easy cases (empty, if, while, print, and
// return) directly as part of this grammar.  For blocks, expression
// statements, and locals, however, a little more work is needed, and
// so we break these pieces out as separate functions.

// Blocks:
// -------

// The easiest of those is the case for blocks.  And the reason it is
// "easy" is because the required code was included in the template
// for StmtAST!  But perhaps it is still worth reflecting on how these
// functions work.  The Block function itself just expects the open and
// close brace symbols that mark the start and end of the block with a
// sequence of zero or more statements in between:
  static final public Stmt Block() throws ParseException {
                Stmt[] stmts;
    jj_consume_token(25);
    stmts = Stmts(0);
    jj_consume_token(26);
    {if (true) return new Block(stmts);}
    throw new Error("Missing return statement in function");
  }

// The Stmts() function is more interesting because it has a parameter
// that specifies how many statements have been read "so far" in the
// current block.  This is a trick that we first saw in Step 08 of the
// Week 3 lab (aka javacctour), and the value of soFar is useful because
// it helps us to figure out the size of the array that we will need to
// hold all of the statement objects that have been parsed.
  static final public Stmt[] Stmts(int soFar) throws ParseException {
                           Stmt s; Stmt[] stmts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 16:
    case 17:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
    case IDENT:
      s = Stmt();
      stmts = Stmts(soFar+1);
      stmts[soFar]=s; {if (true) return stmts;}
      break;
    default:
      jj_la1[18] = jj_gen;
      {if (true) return new Stmt[soFar];}
    }
    throw new Error("Missing return statement in function");
  }

// Stripping away the Java code here, the underlying grammar that we
// are working with is: Stmts -> (Stmt Stmts | ), which could also be
// presented by a pair of productions:
//
//      Stmts -> Stmt Stmts    // one or more statements
//      Stmts ->               // zero statements
//
// You should recognize this as an example of the way we would have
// dealt with something of the form Stmt* as part of a transformation
// to eliminate left recursion.  In other words, this corresponds to
// a production Stmts -> Stmt* that you might have reasonably used in
// the Stmt step of the assignment before you started to wonder about
// adding abstract syntax trees in StmtAST.

// Now when we add the Java code back in, the right hand side of the
// production becomes (s=Stmt() stmts=Stmts(soFar+1) {C1} | {C2}).
// Here, C1 is code the captures the first statement object that was
// parsed and saves it in the array stmts that contains all of the
// following statements.  C2, on the other hand, takes care of
// allocating space for the array when we reach the end of the list
// inside a block, at which point we know that the array should have
// precisely soFar elements, but we will have to rely on the preceding
// recursive calls to Stmt to fill in the individual array entries.

// Expression statements:
// ----------------------

// Although the ExprStmt and StmtExpr names are confusingly similar, it
// is actually quite easy to deal with this part of the grammar given
// what we have already done.  The trick is to remember that any
// StmtExpr (i.e., an Assign or Call expression) can be used as an
// ExprStmt (i.e., as a statment) by passing the AST for the expression
// as an argument to the ExprStmt constructor.  Having already defined
// functions for parsing both assignments and calls, we can implement
// the ExprStmt parsing function directly as follows:
  static final public ExprStmt ExprStmt() throws ParseException {
                       StmtExpr e;
    e = StmtExpr();
    {if (true) return new ExprStmt(e);}
    throw new Error("Missing return statement in function");
  }

  static final public StmtExpr StmtExpr() throws ParseException {
                        StmtExpr e;
    if (jj_2_3(2)) {
      e = Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        e = Call();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

// The only slight trick here is that we need to specify a LOOKAHEAD(2).
// But JavaCC will point that out for us automatically, and it is easy
// to see why this is necessary:  The assignment expression p = 1 and
// the call expression p(1) both start with an identifier, but the
// parser can easily distinguish between them if it looks beyond the
// first token for either an "=" symbol or else for an "(".

// Local variable declarations:
// ----------------------------

// A local variable declaration begins with a type and ends with a
// semicolon.  In between, it requires a list of one or more "variable
// introductions" separated by commas.
  static final public Locals Locals() throws ParseException {
                   Type t; VarIntro[] vs;
    t = Type();
    vs = VarIntros(0);
    jj_consume_token(16);
    {if (true) return new Locals(t, vs);}
    throw new Error("Missing return statement in function");
  }

// The code for parsing types was given in the StmtAST Template,
// and is a just a simple alternative:
  static final public Type Type() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 27:
      jj_consume_token(27);
                {if (true) return Type.INT;}
      break;
    case 28:
      jj_consume_token(28);
                {if (true) return Type.DOUBLE;}
      break;
    case 29:
      jj_consume_token(29);
                {if (true) return Type.BOOLEAN;}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// But what about the variable introductions?  Parsing a single
// variable introduction---either just a variable name, or else
// a variable name together with an initializing expression---is
// straightforward.  Your initial grammar for this might have
// looked something like the following:
//
//   VarIntro -> <IDENT>               // just names a variable
//   VarIntro -> <IDENT> "=" Expr()    // name and initial value
//
// After left factoring and the addition of code to construct the
// appropriate VarIntro or InitVarIntro objects, we obtain the
// following:
  static final public VarIntro VarIntro() throws ParseException {
                       Token t; Expr e;
    t = jj_consume_token(IDENT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 15:
      jj_consume_token(15);
      e = Expr();
                    {if (true) return new InitVarIntro(t.image, e);}
      break;
    default:
      jj_la1[21] = jj_gen;
                    {if (true) return new VarIntro(t.image);}
    }
    throw new Error("Missing return statement in function");
  }

// Note that left factoring wasn't strictly necessary here; we could
// have used another LOOKAHEAD(2) here to help our parser look beyond
// the common <IDENT> prefix and check for the following "=" that
// distinguishes an InitVarIntro.  But it is nice to avoid using
// LOOKAHEAD when possible, and as we'll see soon, there are also times
// when left factoring is the only viable option ...

// Now we know to read a single variable introduction, it's time to
// build the VarIntros() function that will read an array with multiple
// entries.  We'll use the same basic "soFar" trick that was described
// previously for Blocks.  But this time we have a slightly different
// grammar to work with.  Whereas a Block can contain "zero or more
// statements" (without explicit separators), a list of VarIntros is
// required to contain at least one VarIntro, and each entry in the
// list must be separated from the others by a comma.  (On stylistic
// grounds, we would probably not want to allow empty declarations
// like "int;" or declarations without commas like "int x y;".)  As
// you think about the kind of grammar that is needed here, you will
// likely come up with something like this:
//
//    VarIntros -> VarIntro ("," VarIntro)*
//
// Or, translating that into recursive form (which is necessary here
// to use the "soFar" trick):
//
//    VarIntros -> VarIntro "," VarIntros   // more than one VarIntro
//    VarIntros -> VarIntro                 // exactly one VarIntro
//
// After left factoring, we get:
//
//    VarIntros -> VarIntro ("," VarIntros | )
//
// [Aside: Returning briefly to an earlier point, no matter how large a
// value of N we chose, it would not be possible to use a LOOKAHEAD(N)
// annotation to distinguish beween the two productions in the previous
// grammar.  The reason for this is that a single VarIntro could, in
// theory, take any number of tokens: as a pathological example, for any
// value of N, we could construct a VarIntro of the form x = (...(1)...)
// with N open parenthese, and N close parenthese, for a total length of
// 2N+2 tokens.  Technically speaking, JavaCC does have a different
// LOOKAHEAD mechanism that could be used in situations like this.  But
// (a) we haven't ever discussed it, and (b) it is unnecessary given the
// fact that left factoring is very easy in this case.]
//
// But back to VarIntros ... taking the grammar above, we can insert
// some Java code to capture the array of variable introductions that
// is parsed:
  static final public VarIntro[] VarIntros(int soFar) throws ParseException {
                                   VarIntro v; VarIntro[] vs;
    v = VarIntro();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 30:
      jj_consume_token(30);
      vs = VarIntros(soFar+1);
      break;
    default:
      jj_la1[22] = jj_gen;
                  vs = new VarIntro[soFar+1];
    }
    vs[soFar] = v; {if (true) return vs;}
    throw new Error("Missing return statement in function");
  }

// We start be reading the initial variable introduction and saving
// its AST in the variable v.  Then we look for a comma, indicting
// that there are more VarIntros in this list, which we capture in the
// variable vs.  At this point, we have seen one more VarIntro (the
// value in v) than had been seen "so far" when we started, which is
// why the recursive call to VarIntros uses soFar+1 as its argument.
// On the other hand, if there is no comma, then we have reached the
// end of the list and can construct an empty array to store the
// (soFar+1) VarIntro objects that have been seen in this list.
// Either way, when we get to the last line of the function, the
// variable vs holds an array containing all of the following VarIntro
// values, and we just need to save the additional VarIntro v that we
// saw at the start of the call and then return the array.  There's
// quite a lot going on in those few lines of code!

// But that just about wraps things up for StmtAST!

//- Programs ----------------------------------------------------------

// Now we are ready for some "Fun"!  And in fact this final stage will
// be quite a bit easier now that we have some of the examples from what
// has gone before to draw on.

// Complete programs comprise a sequence of zero or more definitions.
// (One could quibble with the decision to include programs that contain
// no definitions: how useful could such programs be in practice?  But
// the code that was supplied in the template allows this, so it is
// easier to go with that for now.  Perhaps static analysis will deal
// with this indirectly by insisting that every program contains a main
// function ...)  Note that the approach used here is exactly the same
// method that we used to parse lists of statements inside blocks; all
// that changes are the names of the types involved (Defn and Defn[]
// instead of Stmt and Stmt[]) and, for their mnemonic value, the names
// of local variables:
  static final public Defn[] Top() throws ParseException {
                Defn[] program;
    program = Program(0);
    jj_consume_token(0);
    {if (true) return program;}
    throw new Error("Missing return statement in function");
  }

  static final public Defn[] Program(int soFar) throws ParseException {
                             Defn d; Defn[] program;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 27:
    case 28:
    case 29:
    case 31:
      d = Defn();
      program = Program(soFar+1);
      program[soFar] = d; {if (true) return program;}
      break;
    default:
      jj_la1[23] = jj_gen;
      {if (true) return new Defn[soFar];}
    }
    throw new Error("Missing return statement in function");
  }

// We have relied on a function called Defn() to parse a single
// definition, which could be either a global variable definition or a
// function definition.  This can be coded easily enough as a simple
// alternative, although we will require a LOOKAHEAD(3) because we need
// to consider three tokens to distinguish between a variable definition
// like "int x=...;" and a function definition like "int x(...) ...".
  static final public Defn Defn() throws ParseException {
               Defn d;
    if (jj_2_4(3)) {
      d = Globals();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 27:
      case 28:
      case 29:
      case 31:
        d = Function();
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return d;}
    throw new Error("Missing return statement in function");
  }

// Global variable declarations are particularly easy to parse now: we
// can reuse almost all of the code for local variable declarations, the
// only real difference being that we must end by constructing a Globals
// object (which is a kind of Defn) rather than a Locals object (which
// is a kind of Stmt):
  static final public Defn Globals() throws ParseException {
                  Type t; VarIntro[] vs;
    t = Type();
    vs = VarIntros(0);
    jj_consume_token(16);
    {if (true) return new Globals(t, vs);}
    throw new Error("Missing return statement in function");
  }

// Function defintions begin with the return type (or "void" for any
// function that does not return a result), followed by the function
// name and a list of formal parameters.  The last component of a
// function definition is the body, which should be a statement block:
  static final public Defn Function() throws ParseException {
                   Type t; Token t1; Formal[] formals; Stmt body;
    t = RetType();
    t1 = jj_consume_token(IDENT);
    jj_consume_token(13);
    formals = Formals();
    jj_consume_token(14);
    body = Block();
    {if (true) return new Function(t, t1.image, formals, body);}
    throw new Error("Missing return statement in function");
  }

// We can parse the return type of a function by reusing the previous
// Type() parsing function but throwing an extra test for a "void"
// function that does not return a value:
  static final public Type RetType() throws ParseException {
                  Type t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 27:
    case 28:
    case 29:
      t = Type();
      break;
    case 31:
      jj_consume_token(31);
             t = null;
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

// The last tricky step in this assignment has to do with parsing the
// list of formal parameters, which provides us another variant of the
// problems that we've seen previously where a parsing function is
// expected to return an array of values.  The code that we used
// previously to parse a comma-separated list of VarIntro values in a
// local declaration provides a good model here: the structure in the
// following code is exactly the same as what we saw previously; only
// the names have changed.
  static final public Formal[] Formals1(int soFar) throws ParseException {
                                Formal f; Formal[] formals;
    f = Formal();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 30:
      jj_consume_token(30);
      formals = Formals1(soFar+1);

      break;
    default:
      jj_la1[26] = jj_gen;
                 formals = new Formal[soFar+1];
    }
    formals[soFar] = f; {if (true) return formals;}
    throw new Error("Missing return statement in function");
  }

// The problem now is that this definition only allows lists that have
// *one or more* entries in them: this is why we used the suffix "1" on
// the above parsing function ... but we would also like to handle an
// empty list of parameters for use in function definitions of the form
// "int f() {...}".  The easiest way to handle this is to have the
// parser consider two alternatives when it looks for the parameters to
// the call.  If the parser finds a non-empty array of formal
// parameters, then it it takes the first alternative and returns that
// array as its result.  Otherwise, in the second alternative, our parser
// does not consume any input, and instead constructs and returns a zero
// length array of formal parameters:
  static final public Formal[] Formals() throws ParseException {
                      Formal[] formals;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 27:
    case 28:
    case 29:
      formals = Formals1(0);
      break;
    default:
      jj_la1[27] = jj_gen;
                            formals=new Formal[0];
    }
    {if (true) return formals;}
    throw new Error("Missing return statement in function");
  }

// Examples like this can test your eyesight and your understanding of
// JavaCC syntax: in particular, make sure you distinguish between the
// parts of the above rule inside {...} braces (embedded Java code) and
// the parts inside (...) parentheses (which are just for grouping).

// Now that we have the skeleton of code to parse a non-empty list of
// formal parameters, we just need to add code for reading a single,
// formal parameter specification.  As indicated in the assignment
// text, a formal parameter ``takes the form "type varname" and
// specifies the type and name of an input to the function'':
  static final public Formal Formal() throws ParseException {
                   Type t; Token t1;
    t = Type();
    t1 = jj_consume_token(IDENT);
    {if (true) return new Formal(t, t1.image);}
    throw new Error("Missing return statement in function");
  }

// The only remaining detail left is to complete the description of
// parsing for function calls by specifiying how the Args() function,
// used previously in the definition of Call(), should handle argument
// lists.  We have delayed that until now because it follows exactly
// the same pattern as we have just seen for formal parameters.  (This
// is a very good thing: it would probably be a very confusing language
// design if function calls and function definitions used fundamentally
// different syntax ...).  To see the parallels here, be sure to compare
// the following definitions of Args() and Args1() with those given
// previously for Formals() and Formals1():
  static final public Expr[] Args() throws ParseException {
                 Expr[] args;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 10:
    case 13:
    case IDENT:
    case INTLIT:
    case FLOATLIT:
      args = Args1(0);
      break;
    default:
      jj_la1[28] = jj_gen;
                      args=new Expr[0];
    }
    {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  static final public Expr[] Args1(int soFar) throws ParseException {
                           Expr e; Expr[] args;
    e = Expr();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 30:
      jj_consume_token(30);
      args = Args1(soFar+1);

      break;
    default:
      jj_la1[29] = jj_gen;
               args = new Expr[soFar+1];
    }
    args[soFar] = e; {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_3R_13() {
    return false;
  }

  static private boolean jj_3R_11() {
    if (jj_scan_token(IDENT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    }
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_3()) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_5()) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_scan_token(30)) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_3()) return true;
    return false;
  }

  static private boolean jj_3R_4() {
    if (jj_scan_token(IDENT)) return true;
    if (jj_scan_token(13)) return true;
    return false;
  }

  static private boolean jj_3R_5() {
    if (jj_3R_6()) return true;
    if (jj_3R_7()) return true;
    if (jj_scan_token(16)) return true;
    return false;
  }

  static private boolean jj_3R_10() {
    if (jj_scan_token(29)) return true;
    return false;
  }

  static private boolean jj_3R_7() {
    if (jj_3R_11()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) return true;
    }
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(28)) return true;
    return false;
  }

  static private boolean jj_3R_8() {
    if (jj_scan_token(27)) return true;
    return false;
  }

  static private boolean jj_3R_3() {
    if (jj_scan_token(IDENT)) return true;
    if (jj_scan_token(15)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_4()) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    if (jj_scan_token(15)) return true;
    return false;
  }

  static private boolean jj_3R_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_8()) {
    jj_scanpos = xsp;
    if (jj_3R_9()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) return true;
    }
    }
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2400,0x2,0x4,0x1f8,0x1f8,0x600,0x600,0x1800,0x1800,0x2400,0x0,0x40000,0x2400,0x3bfb0000,0x38000000,0x0,0x2400,0x0,0x3bfb0000,0x0,0x38000000,0x8000,0x40000000,0xb8000000,0xb8000000,0xb8000000,0x40000000,0x38000000,0x2400,0x40000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x8c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8c0,0x0,0x8c0,0x40,0x40,0x40,0x8c0,0x40,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8c0,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[4];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        exists = true;
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[44];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 44; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
